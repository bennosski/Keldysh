# -*- coding: utf-8 -*-
"""
Created on Thu Dec 08 01:44:04 2016

@author: Ben
"""

try:
    from mpi4py import MPI
    comm = MPI.COMM_WORLD
    nprocs = comm.size
    myrank = comm.rank
except ImportError:
    print('MPI not found')
    myrank = 0
    nprocs = 1

import src
    
import pdb
import numpy as np
import time
import sys, os
from langreth import *
import shutil
from util import *
from functions import *
import integration
from matsubara import *
from plotting import *

savedir = sys.argv[1]

if myrank==0:
    time0 = time.time()
    
if myrank==0:
    print(' ')
    print('nprocs = ',nprocs)
    
mymkdir(savedir)
mymkdir(savedir+'Gdir/')
mymkdir(savedir+'G2x2dir/')

Nkx = 1
Nky = 1
k2p, k2i, i2k = init_k2p_k2i_i2k(Nkx, Nky, nprocs, myrank)
kpp = np.count_nonzero(k2p==myrank)

def main():
    
    beta = 2.0
    ARPES = False
    pump = 0
    g2 = None
    omega = None
    tmax = 4.0

    e1   = -0.1
    e2   =  0.1
    lamb = 1.0

    order = 6
    
    ntau = 200

    nts = [10, 20, 100]
    
    diffs = {}
    diffs['nts'] = nts
    diffs['M']  = []
    diffs['IR'] = []
    diffs['R']  = []
    diffs['L']  = []
    
    for nt in nts:

        # Solve Matsubara problem first
        
        #---------------------------------------------------------
        # compute non-interacting G for the 2x2 problem (exact solution)

        norb = 2
        def H(kx, ky):
            return np.array([[e1, lamb], [np.conj(lamb), e2]], dtype=complex)

        constants = (myrank, Nkx, Nky, ARPES, kpp, k2p, k2i, tmax, nt, beta, ntau, norb, pump)
        UksR, UksI, eks, fks, Rs = init_Uks(H, *constants)
        G2x2M = compute_G0M(0, 0, UksR, UksI, eks, fks, Rs, *constants)
        G2x2  = compute_G0R(0, 0, G2x2M, UksR, UksI, eks, fks, Rs, *constants)
        
        #------------------------------------------------------
        # compute Sigma_embedding
        # Sigma = |lambda|^2 * g22(t,t')

        norb = 1
        def H(kx, ky): return e2*np.ones([1,1])
        constants = (myrank, Nkx, Nky, ARPES, kpp, k2p, k2i, tmax, nt, beta, ntau, norb, pump)
        UksR, UksI, eks, fks, Rs = init_Uks(H, *constants)
        SigmaM = compute_G0M(0, 0, UksR, UksI, eks, fks, Rs, *constants)
        SigmaM.scale(lamb*np.conj(lamb))
        Sigma = compute_G0R(0, 0, SigmaM, UksR, UksI, eks, fks, Rs, *constants)
        Sigma.scale(lamb*np.conj(lamb))

        #------------------------------------------------------
        # solve the embedding problem
        
        norb = 1
        def H(kx, ky): return e1*np.ones([1,1])
        constants = (myrank, Nkx, Nky, ARPES, kpp, k2p, k2i, tmax, nt, beta, ntau, norb, pump)
        UksR, UksI, eks, fks, Rs = init_Uks(H, *constants)
        G0M = compute_G0M(0, 0, UksR, UksI, eks, fks, Rs, *constants)
        G0  = compute_G0R(0, 0, G0M, UksR, UksI, eks, fks, Rs, *constants)
                
        integrator = integration.integrator(6, nt, beta, ntau, norb)

        GM = matsubara(beta, ntau, norb, -1)
        integrator.dyson_matsubara(G0M, SigmaM, GM)
        G  = langreth(nt, tmax, GM)
        integrator.dyson_langreth(G0, Sigma, G)
        
        def im_plot(x, y):
            y1 = x[:,0,:,0]
            y2 = y[:,0,:,0]
            im([y1.imag, y2.imag, y1.imag-y2.imag], [0,tmax,0,tmax], 'imag')
            im([y1.real, y2.real, y1.real-y2.real], [0,tmax,0,tmax], 'real')

        diff = np.mean(abs(GM.M[:,0,0]-G2x2M.M[:,0,0]))
        print('diff = %1.3e'%diff)
        diffs['M'].append(diff)
        
        diff = np.mean(abs(G.R[:,0,:,0]-G2x2.R[:,0,:,0]))
        print('diff langreth R = %1.3e'%diff)
        diffs['R'].append(diff)
        
        #im_plot(G.R, G2x2.R)
        
        diff = np.mean(abs(G.IR[:,0,:,0]-G2x2.IR[:,0,:,0]))
        print('diff langreth IR = %1.3e'%diff)
        diffs['IR'].append(diff)
        
        #im_plot(G.IR, G2x2.IR)

        diff = np.mean(abs(G.L[:,0,:,0]-G2x2.L[:,0,:,0]))
        print('diff langreth L = %1.3e'%diff)
        diffs['L'].append(diff)
        
        #im_plot(G.L, G2x2.L)
        
        #------------------------------------------------------

    plt_diffs(diffs)
        
    if 'MPI' in sys.modules:
        MPI.Finalize()


def multiply_test():

    beta = 2.0
    ARPES = False
    pump = 0
    g2 = None
    omega = None
    tmax = 10.0

    e1 = -0.1
    e2 =  0.1
    lamb = 1.0

    ntau = 200
    
    order = 6
    
    #nts = [10, 20, 100, 400, 600]
    #nts = [10, 50, 100, 500, 1000]
    nts = [10, 50, 100]

    #nts = [20]
    
    diffs = {}
    diffs['nts'] = nts

    diffs['RxR'] = []
    diffs['MxIR'] = []
    #diffs['MxM'] = []
    diffs['RIxIR'] = []
    diffs['IRxA'] = []
    diffs['LxA'] = []
    diffs['RxL'] = []
    
    for nt in nts:
        
        # compute Sigma_embedding
        # Sigma = |lambda|^2 * g22(t,t')

        norb = 1
        def H(kx, ky): return e2*np.ones([1,1])
        constants = (myrank, Nkx, Nky, ARPES, kpp, k2p, k2i, tmax, nt, beta, ntau, norb, pump)
        UksR, UksI, eks, fks, Rs = init_Uks(H, *constants)
        SigmaM = compute_G0M(0, 0, UksR, UksI, eks, fks, Rs, *constants)
        SigmaM.scale(lamb*np.conj(lamb))
        Sigma = compute_G0R(0, 0, SigmaM, UksR, UksI, eks, fks, Rs, *constants)
        Sigma.scale(lamb*np.conj(lamb))

        # solve the embedding problem

        norb = 1
        def H(kx, ky): return e1*np.ones([1,1])
        constants = (myrank, Nkx, Nky, ARPES, kpp, k2p, k2i, tmax, nt, beta, ntau, norb, pump)
        UksR, UksI, eks, fks, Rs = init_Uks(H, *constants)
        G0M = compute_G0M(0, 0, UksR, UksI, eks, fks, Rs, *constants)
        G0  = compute_G0R(0, 0, G0M, UksR, UksI, eks, fks, Rs, *constants)

        integrator = integration.integrator(order, nt, beta, ntau, norb)

        #im([integrator.gregory_matrix_R, np.tril(np.ones((nt,nt)))], [0,tmax,0,tmax], 'gregory matrix')
        #exit()

        
        diff_mean = MxM_test(integrator, G0, Sigma, e1, e2, lamb, tmax, nt, beta, ntau)
        #diffs['MxM'].append(diff_mean)

        diff_mean = MxIR_test(integrator, G0, Sigma, e1, e2, lamb, tmax, nt, beta, ntau)
        diffs['MxIR'].append(diff_mean)
        
        diff_mean = RxR_test(integrator, G0, Sigma, e1, e2, lamb, tmax, nt, beta, ntau)
        diffs['RxR'].append(diff_mean)

        exit()
        
        diff_mean = RIxIR_test(integrator, G0, Sigma, e1, e2, lamb, tmax, nt, beta, ntau)
        diffs['RIxIR'].append(diff_mean)
        diff_mean = IRxA_test(integrator, G0, Sigma, e1, e2, lamb, tmax, nt, beta, ntau)
        diffs['IRxA'].append(diff_mean)
        diff_mean = LxA_test(integrator, G0, Sigma, e1, e2, lamb, tmax, nt, beta, ntau)
        diffs['LxA'].append(diff_mean)
        diff_mean = RxL_test(integrator, G0, Sigma, e1, e2, lamb, tmax, nt, beta, ntau)
        diffs['RxL'].append(diff_mean)

        
    if len(nts)>1:
        #np.save(savedir+'diffs.npy', diffs)
        #np.save(savedir+'nts.npy', nts)
        
        #log_nts = np.log(array(nts))
        #log_diffs = np.log(np.array(diffs))
        #plt(log_nts, [log_diffs], 'diffs')

        #slope = (log_diffs[-1]-log_diffs[0])/(log_nts[-1]-log_nts[0])
        #print('slope = %1.3f'%slope)

        plt_diffs(diffs)
        

        
def RxL_test(integrator, G0, Sigma, e1, e2, lamb, tmax, nt, beta, ntau):
    P = integrator.RxL(G0, Sigma)
    
    ts = linspace(0, tmax, nt)
    taus = linspace(0, beta, ntau)    

    fe1 = 1.0/(np.exp(beta*e1)+1.0)
    fe2 = 1.0/(np.exp(beta*e2)+1.0)
    
    Pexact = fe2/(1j*(e1-e2))*np.exp(-1j*e1*ts[:,None])*np.exp(1j*e2*ts[None,:])*(np.exp(1j*(e1-e2)*ts[:,None]) - 1.0)
    Pexact *= lamb*np.conj(lamb)

    y1 = P[:,0,:,0]
    y2 = Pexact[:,:]
    #im([y1.real, y2.real, y1.real-y2.real], [0,beta,0,tmax], 'P and Pexactfor MxIR')
    #im([y1.imag, y2.imag, y1.imag-y2.imag], [0,beta,0,tmax], 'P and Pexactfor MxIR')
    
    diff_mean = np.mean(abs(P[:,0,:,0]-Pexact[:,:]))
    print('diff mean', diff_mean)
        
    return diff_mean    

def LxA_test(integrator, G0, Sigma, e1, e2, lamb, tmax, nt, beta, ntau):
    P = integrator.LxA(G0, Sigma)
    
    ts = linspace(0, tmax, nt)
    taus = linspace(0, beta, ntau)    

    fe1 = 1.0/(np.exp(beta*e1)+1.0)
    fe2 = 1.0/(np.exp(beta*e2)+1.0)
    
    Pexact = -fe1*np.exp(-1j*e1*ts[:,None])*np.exp(1j*e2*ts[None,:])/(1j*(e1-e2)) * (np.exp(1j*(e1-e2)*ts[None,:]) - 1.0)
    Pexact *= lamb*np.conj(lamb)

    y1 = P[:,0,:,0]
    y2 = Pexact[:,:]
    #im([y1.real, y2.real, y1.real-y2.real], [0,beta,0,tmax], 'P and Pexactfor MxIR')

    #im([y1.imag, y2.imag, y1.imag-y2.imag], [0,beta,0,tmax], 'P and Pexactfor MxIR')
    
    diff_mean = np.mean(abs(P[:,0,:,0]-Pexact[:,:]))
    print('diff mean', diff_mean)
        
    return diff_mean    
               
def IRxA_test(integrator, G0, Sigma, e1, e2, lamb, tmax, nt, beta, ntau):
    P = integrator.IRxA(G0, Sigma)
    
    ts = linspace(0, tmax, nt)
    taus = linspace(0, beta, ntau)    

    fe1 = 1.0/(np.exp(beta*e1)+1.0)
    fe2 = 1.0/(np.exp(beta*e2)+1.0)
    
    Pexact = -(fe1-1.0)*np.exp(-e1*taus[:,None])*np.exp(1j*e2*ts[None,:])/(1j*(e1-e2)) * (np.exp(1j*(e1-e2)*ts[None,:]) - 1.0)
    Pexact *= lamb*np.conj(lamb)

    y1 = P[:,0,:,0]
    y2 = Pexact[:,:]
    #im([y1.real, y2.real, y1.real-y2.real], [0,beta,0,tmax], 'P and Pexactfor MxIR')

    #im([y1.imag, y2.imag, y1.imag-y2.imag], [0,beta,0,tmax], 'P and Pexactfor MxIR')
    
    diff_mean = np.mean(abs(P[:,0,:,0]-Pexact[:,:]))
    print('diff mean', diff_mean)
        
    return diff_mean    
        
def RIxIR_test(integrator, G0, Sigma, e1, e2, lamb, tmax, nt, beta, ntau):
    P = integrator.RIxIR(G0, Sigma)
    
    ts = linspace(0, tmax, nt)
    taus = linspace(0, beta, ntau)    

    fe1 = 1.0/(np.exp(beta*e1)+1.0)
    fe2 = 1.0/(np.exp(beta*e2)+1.0)
    
    Pexact  = 1j/(e1-e2)*fe1*(fe2-1)*np.exp(-1j*e1*ts[:,None])*np.exp(-beta*e2)*np.exp(1j*e2*ts[None,:])*(np.exp(beta*e1)-np.exp(beta*e2))
    Pexact *= lamb*np.conj(lamb)

    y1 = P[:,0,:,0]
    y2 = Pexact[:,:]
    #im([y1.real, y2.real, y1.real-y2.real], [0,beta,0,tmax], 'P and Pexactfor MxIR')

    #im([y1.imag, y2.imag, y1.imag-y2.imag], [0,beta,0,tmax], 'P and Pexactfor MxIR')
    
    diff_mean = np.mean(abs(P[:,0,:,0]-Pexact[:,:]))
    print('diff mean', diff_mean)
        
    return diff_mean    
            
def MxM_test(integrator, G0, Sigma, e1, e2, lamb, tmax, nt, beta, ntau):
    norb = 1
    P = integrator.MxM(G0, Sigma)
    
    taus = linspace(0, beta, ntau)
    
    fe1 = 1.0/(np.exp(beta*e1)+1.0)
    fe2 = 1.0/(np.exp(beta*e2)+1.0)

    Pexact = lamb*np.conj(lamb)*1j/(e1-e2)*(fe2-1.0)*np.exp(-e1*taus) * ( -fe1 - np.exp((e1-e2)*taus) + 1.0 + fe1*np.exp((e1-e2)*beta))
                                                       
    y1 = P[:,0,0]
    y2 = Pexact[:]
    #plt(taus, [y1.real, y2.real], 'P and Pexactfor MxM')
    #plt(taus, [y1.imag, y2.imag], 'P and Pexactfor MxM')
    
    diff_mean = np.mean(abs(P[:,0,0]-Pexact[:]))
    print('diff mean', diff_mean)
        
    return diff_mean    
                
def MxIR_test(integrator, G0, Sigma, e1, e2, lamb, tmax, nt, beta, ntau):
    P = integrator.MxIR(G0, Sigma)
    
    ts = linspace(0, tmax, nt)
    taus = linspace(0, beta, ntau)    

    fe1 = 1.0/(np.exp(beta*e1)+1.0)
    fe2 = 1.0/(np.exp(beta*e2)+1.0)
    
    Pexact  = 1j/(e2-e1)*(fe1-1)*(fe2-1)*np.exp(1j*e2*ts[None,:])*(np.exp(-e1*taus[:,None]) - np.exp(-e2*taus[:,None]))
    Pexact += 1j/(e2-e1)*fe1*(fe2-1)*np.exp(1j*e2*ts[None,:])*(np.exp(-e2*taus[:,None]) - np.exp((beta-taus[:,None])*e1)*np.exp(-beta*e2))
    Pexact *= lamb*np.conj(lamb)

    y1 = P[:,0,:,0]
    y2 = Pexact[:,:]
    #im([y1.real, y2.real, y1.real-y2.real], [0,beta,0,tmax], 'P and Pexactfor MxIR')

    #im([y1.imag, y2.imag, y1.imag-y2.imag], [0,beta,0,tmax], 'P and Pexactfor MxIR')
    
    diff_mean = np.mean(abs(P[:,0,:,0]-Pexact[:,:]))
    print('diff mean', diff_mean)
        
    return diff_mean    
        
def RxR_test(integrator, G0, Sigma, e1, e2, lamb, tmax, nt, beta, ntau):
    P = integrator.RxR(G0, Sigma)

    ts = linspace(0, tmax, nt)
    
    Pexact = lamb*np.conj(lamb)/(1j*(e1-e2)) * (np.exp(-1j*e1*(ts[:,None]-ts[None,:])) - np.exp(-1j*e2*(ts[:,None]-ts[None,:])))

    y1 = P[:,0,:,0]
    y2 = Pexact
    im([y1.real, y2.real, y1.real-y2.real], [0,tmax,0,tmax], 'P and Pexact')

    im([y1.imag, y2.imag, y1.imag-y2.imag], [0,tmax,0,tmax], 'P and Pexact')
    
    print('shape P', np.shape(P))
    print('shape Pexact', np.shape(Pexact))
    print('diff max ', np.amax(abs(P[:,0,:,0]-Pexact[:,:])))
    diff_mean = np.mean(abs(P[:,0,:,0]-Pexact[:,:]))
    print('diff mean', diff_mean)
        
    return diff_mean
    
    
if __name__=='__main__':
    main()
    #multiply_test()
        


